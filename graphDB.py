#! /usr/bin/env python
'''
Author: Christopher Mannes  
Student ID: 20743505

ECE 650 - Methods and Tools for Software Engineering
Assignment 3 - Python Database

a1ece650.py takes input from the user in the form of 
-> "command (x1,y1) (x2,y2) (x3,y3) ..."
and generate a database of street names and stree 
coordinates and subsequently determine all intersections
of the streets in the database and output the results in
a specified format. 
'''

# Import libraries.
import os
import sys
import string
import logging
import math as m
from copy import deepcopy

# Set up logging
log = "graphDB_py.log"
logging.basicConfig(filename=log, filemode="w", level=logging.DEBUG) 
# logging.basicConfig(filename=log,level=logging.DEBUG,format='%(asctime)s %(message)s', datefmt='%d/%m/%Y %H:%M:%S')
logging.info('Begin Logging file.')

class StreetList():

    # Intializes empty lists for database.
    def __init__(self):
        self.listOfStreetNames = []
        self.listOfStreetCoord = []

    # Function to add a street to the database if it does not exist in the database already.
    def addStreet(self, name, coordList):
        if name in self.listOfStreetNames:
            sys.stderr.write("Error: This street is already assigned. Use 'change' operation.")
        else:
            self.listOfStreetNames.append(name)
            self.listOfStreetCoord.append(coordList)

    # Function to remove street from the database if it exists in the database.
    def removeStreet(self, name):
        try:
            nameIndex = self.listOfStreetNames.index(name)
            self.listOfStreetNames.remove(name)
            del self.listOfStreetCoord[nameIndex]

        except ValueError:
            sys.stderr.write("Error: Cannot perform 'remove' operation. Specified street does not exist.\n")

    # Function to alter the points in a street.
    def changeStreet(self, name, coordList):
        try:
            nameIndex = self.listOfStreetNames.index(name)
            self.listOfStreetCoord[nameIndex] = coordList

        except ValueError:
            sys.stderr.write("Error: Cannot perform 'change' operation. Specified street does not exist.\n")

    # Function for generating an undirected graph.
    def generateGraph(self):

        # Initialize a set of lists for graph generation.
        vertexList = []
        edgeList = []
        intersectionVertices = []
        varListOfStreetCoord = deepcopy(self.listOfStreetCoord)

        # Function to generate a line between two points in x-y space.
        # Produces coefs A, B, C of line equation by the two points provided.
        def line(p1, p2):
            # A1 * x + B1 * y = C1
            # A2 * x + B2 * y = C2
            A = (p1[1] - p2[1])
            B = (p2[0] - p1[0])
            C = (p1[0] * p2[1] - p2[0] * p1[1])

            return A, B, -C

        # Function to determine the intersection between two lines.
        # The determinant between two lines is calculated, if the 
        # determinant is non-zero and the intersection is between 
        # the bounds of the line segements, then the point is added
        # to the list of vertices.
        # https://stackoverflow.com/questions/20677795/how-do-i-compute-the-intersection-point-of-two-lines
        def intersection(L1, L2, vertexList, intersectionVertices):
            D  = L1[0] * L2[1] - L1[1] * L2[0]
            Dx = L1[2] * L2[1] - L1[1] * L2[2]
            Dy = L1[0] * L2[2] - L1[2] * L2[0]
            if D != 0:
                x = Dx / D
                y = Dy / D
                if x >= minX and x <= maxX and y >= minY and y <= maxY:
                    vertexList.append([round(x,5), round(y,5)])
                    intersectionVertices.append([round(x,5), round(y,5)])
                    return vertexList, intersectionVertices
                else:
                    # print("False")
                    return vertexList, intersectionVertices
            else:
                # print("False")
                return vertexList, intersectionVertices

        # Function to determine the angle generated by two points.
        # https://stackoverflow.com/questions/31735499/calculate-angle-clockwise-between-two-points
        def angle_between(p1, p2):
            ang1 = m.atan2(*p1[::-1])
            ang2 = m.atan2(*p2[::-1])
            theta = round((ang1 - ang2) % (2 * m.pi), 5)

            return theta

        def thetaAngle(point1, point2):
            # print("-------------")
            x1, y1 = point1
            # print("x1 and y1", x1, y1)
            x2, y2 = point2
            # print("x2 and y2", x2, y2)
            innerProduct = x1*x2 + y1*y2
            # print("inner", innerProduct)
            length1 = m.sqrt(x1**2 + y1**2)
            length2 = m.sqrt(x2**2 + y2**2)
            # print("l1 and l2", length1, length2)
            arg = round(innerProduct/(length1*length2),5)
            # print("arg",arg)
            theta = round(m.acos(round(innerProduct/(length1*length2),5)), 5)
            
            return theta

        # Function to center two points at the origin using three points.
        def centerPoints(point1, point2, offsetPoint):
            point1[0] = point1[0] - offsetPoint[0]
            point1[1] = point1[1] - offsetPoint[1]

            point2[0] = point2[0] - offsetPoint[0]
            point2[1] = point2[1] - offsetPoint[1]

            return point1, point2

        # Function to reverse the operation performed by the function centerPoints.
        def revertPoints(intersectionPoint, streetPoint1, streetPoint2):

            intersectionPoint[0] = intersectionPoint[0] + streetPoint2[0]
            intersectionPoint[1] = intersectionPoint[1] + streetPoint2[1]

            streetPoint1[0] = streetPoint1[0] + streetPoint2[0]
            streetPoint1[1] = streetPoint1[1] + streetPoint2[1]

            return intersectionPoint, streetPoint1, streetPoint2

        # Function to determine the Euclidean distance two points.
        def distance(a, b):

            d = m.sqrt( (b[0] - a[0])**2 + (b[1] - a[1])**2 )

            return d

        # Function to determine if a point c is in between to points a and c.
        # This is achieved by determining if the sum of two lengths is the 
        # same as the total length.
        def isBetweenPoints(a, c, b):

            # print(distance(a,c))
            # print(distance(c,b))
            # print(distance(a,b))

            return round((distance(a,c) + distance(c,b)), 1) == round((distance(a,b)), 1)

        # Function for printing the results in a specific format.
        def printGraph(printVerticesList, varListOfStreetCoord, intersectVertices):

            # print("printVerticesList")
            # print(printVerticesList)

            # print("varListOfStreetCoord")
            # print(varListOfStreetCoord)

            # print("intersectVertices")
            # print(intersectVertices)

            # Range of values in vertexNames correspond to the outout labels.
            vertexNames = range(1, len(printVerticesList) + 1)
            
            # Printout for vertices.
            # Separation between values <= 9 and > 9 is to achieve uniform spacing.
            # The [0] and [1] values in each coordinate give a particular node and
            # iterating through the list gives the corresponding labels.
            sys.stdout.write("V = {\n")
            for name in vertexNames:
                if name <= 9:
                    sys.stdout.write('  ' + 
                    str(name) + 
                    ':  ' + 
                    '(' + 
                    str(printVerticesList[name - 1][0]) + 
                    ',' + 
                    str(printVerticesList[name - 1][1]) + 
                    ')\n')
                else:
                    sys.stdout.write('  ' + 
                    str(name) + 
                    ': ' + 
                    '(' + 
                    str(printVerticesList[name - 1][0]) + 
                    ',' + 
                    str(printVerticesList[name - 1][1]) + 
                    ')\n')
            sys.stdout.write("}\n")


            # Printout for edges.
            # Iterates through each list in the list of list.
            # For each list in the list iterate through the nodes in the list and 
            # construct a list with two subsequent nodes (twoNodeList).
            #
            # edgeResult is true if every elem in twoNodeList occurs in intersectVertices
            # else it returns false.
            # If edgeResult is true then an edges element is constructed by determining
            # the index in printVerticesList that the coordinate twoNodeList[0] or
            # twoNodeList[1] occurs at and adds one to get the label/node name.
            # print("varListOfStreetCoord",varListOfStreetCoord)
            # print("\n")
            # print("intersectVertices",intersectVertices)
            # print("\n")
            # print("printVerticesList",printVerticesList)
            edges = []
            for i in range(len(varListOfStreetCoord)):
                for j in range(len(varListOfStreetCoord[i]) - 1):
                    # Iterating through the list of list with the added intersection points 
                    # ensures that two consecutive points are on the same street and can be
                    # traversed without crosssing another node.
                    twoNodeList = [varListOfStreetCoord[i][j], varListOfStreetCoord[i][j + 1]]
                    # print(twoNodeList)
                    # edgeResult is true if any element in twoNodeList is in intersectVertices.
                    edgeResult = any(elem in twoNodeList for elem in intersectVertices)
                    # print(edgeResult)

                    if edgeResult:
                        # print("twoNodeList",twoNodeList)
                        E1 = printVerticesList.index(twoNodeList[0]) + 1
                        E2 = printVerticesList.index(twoNodeList[1]) + 1
                        # print(E1,E2)
                        edges.append([E1, E2])

            # print(edges)

            sys.stdout.write("E = {\n")
            for index in range(len(edges) - 1):
                sys.stdout.write('  ' + 
                '<' + 
                str(edges[index][0]) + 
                ',' + 
                str(edges[index][1]) + 
                '>,\n')
            try:
                sys.stdout.write('  ' + '<'+ str(edges[len(edges)- 1][0]) + ',' + str(edges[len(edges) - 1][1]) + '>\n')
            except:
                pass
            sys.stdout.write("}\n")

            return

        def genOutputForPipe(printVerticesList, varListOfStreetCoord, intersectVertices):
            
            # Range of values in vertexNames correspond to the outout labels.
            vertexNames = range(0, len(printVerticesList))

            # Print out for the number vertices.
            sys.stdout.write("V " + str(len(printVerticesList)) + "\n")
            sys.stdout.flush()
            logging.info("V " + str(len(printVerticesList)))

            # Print out for the set of edges.
            edges = []
            for i in range(len(varListOfStreetCoord)):
                for j in range(len(varListOfStreetCoord[i]) - 1):
                    # Iterating through the list of list with the added intersection points 
                    # ensures that two consecutive points are on the same street and can be
                    # traversed without crosssing another node.
                    twoNodeList = [varListOfStreetCoord[i][j], varListOfStreetCoord[i][j + 1]]
                    # print(twoNodeList)
                    # edgeResult is true if any element in twoNodeList is in intersectVertices.
                    edgeResult = any(elem in twoNodeList for elem in intersectVertices)
                    # print(edgeResult)

                    if edgeResult:
                        E1 = printVerticesList.index(twoNodeList[0]) 
                        E2 = printVerticesList.index(twoNodeList[1])
                        # print(E1,E2)
                        edges.append([E1, E2])

            outputString = "E {"
            # sys.stdout.write("E {")
            for index in range(len(edges) - 1):
                # sys.stdout.write('<' + 
                # str(edges[index][0]) + 
                # ',' + 
                # str(edges[index][1]) + 
                # '>,')
                outputString += '<' + str(edges[index][0]) + ',' + str(edges[index][1]) + '>,'
            try:
                # sys.stdout.write('<'+ str(edges[len(edges)- 1][0]) + ',' + str(edges[len(edges) - 1][1]) + '>')
                outputString += '<'+ str(edges[len(edges)- 1][0]) + ',' + str(edges[len(edges) - 1][1]) + '>'
            except:
                pass
            # sys.stdout.write("}")
            outputString += "}"+"\n"
            
            # sys.stdout.write("V 10\n")
            # sys.stdout.write("E {<3,0>,<0,2>,<7,1>,<1,6>,<5,0>,<0,1>,<1,4>,<9,1>,<1,8>}\n")
            sys.stdout.write(outputString)
            sys.stdout.flush()
            # sys.stdout.write("\n")
            # logging.info(outputString + "\n")

            self.listOfStreetNames = []
            self.listOfStreetCoord = []

            return



        '''
        Iterate through the list of lists to determine intersections.
        Every entry in the first list is checked against entries in 
        the remaining entries of the list. A pop then append approach
        is used at the end to cycle the lists. This is needed as the
        intersection points are considered to be vertices in the given
        problem.
        '''
        for h in range(len(self.listOfStreetCoord)):
            # print("h",h)
            intersectionCounter = 0
            # print(varListOfStreetCoord)

            for i in range( len(self.listOfStreetCoord[0]) - 1 ):
                # print("i",i)

                P1 = self.listOfStreetCoord[0][i]
                P2 = self.listOfStreetCoord[0][i + 1]
                # print(self.listOfStreetCoord[0][i], self.listOfStreetCoord[0][i + 1])
                
                # line1 = line(self.listOfStreetCoord[0][i], self.listOfStreetCoord[0][i + 1])
                line1 = line(P1, P2)

                for j in range(1, len(self.listOfStreetCoord)):
                    # print("j",j)

                    for k in range(len(self.listOfStreetCoord[j]) - 1):
                        # print("k",k)

                        P3 = self.listOfStreetCoord[j][k]
                        P4 = self.listOfStreetCoord[j][k + 1]
                        # print(self.listOfStreetCoord[j][k], self.listOfStreetCoord[j][k + 1])
                        
                        # line2 = line(self.listOfStreetCoord[j][k], self.listOfStreetCoord[j][k + 1])
                        line2 = line(P3, P4)

                        # x > max and x < min
                        minX = max(min(P1[0],P2[0]), min(P3[0],P4[0]))
                        maxX = min(max(P1[0],P2[0]), max(P3[0],P4[0]))

                        # y > max and y < min
                        minY = max(min(P1[1],P2[1]), min(P3[1],P4[1]))
                        maxY = min(max(P1[1],P2[1]), max(P3[1],P4[1]))
                        
                        vertexList, intersectionVertices = intersection(
                            line1,
                            line2,
                            vertexList,
                            intersectionVertices)

            # Pop the first list off and append it to the end.
            self.listOfStreetCoord.append(self.listOfStreetCoord.pop(0))


        # Remove duplicates.
        verticesList = []
        for node in vertexList:
            if node not in verticesList:
                verticesList.append(node)


        # Remove duplicates.
        intersectVertices = []
        for node in intersectionVertices:
            if node not in intersectVertices:
                intersectVertices.append(node)


        
        '''
        Once the intesections are obtained the corrsponding street
        segment is determined and the endpoints of the street segment
        is obtained by centering the street segment at the origin and
        determining if the the points share the same angle. This is 
        needed as the endpoints are considered to be vertices in the
        given problem.
        '''
        for vertex in range(len(verticesList)):
            intersectionPoint = verticesList[vertex]

            for i in range(len(self.listOfStreetCoord)):
                for j in range(len(self.listOfStreetCoord[i]) - 1):

                    streetPoint1 = self.listOfStreetCoord[i][j]
                    streetPoint2 = self.listOfStreetCoord[i][j + 1]
                    # print(streetPoint1)
                    # print(streetPoint2)

                    streetPoint1Flag = False
                    streetPoint2Flag = False

                    point1, point2 = centerPoints(intersectionPoint, streetPoint1, streetPoint2)
                    theta = angle_between(point1, point2)
                    theta = round(theta, 2)
                    # print(round(theta,2))
                    # theta = thetaAngle(point1, point2)

                    if theta == 0 or theta == 6.28:
                        streetPoint1Flag = True

                    intersectionPoint, streetPoint1, streetPoint2 = revertPoints(intersectionPoint,
                                                                                streetPoint1,
                                                                                streetPoint2)
                                                                
                    point1, point2 = centerPoints(intersectionPoint, streetPoint2, streetPoint1)
                    theta = angle_between(point1, point2)
                    theta = round(theta, 2)
                    # print(theta)
                    # theta = thetaAngle(point1, point2)

                    if theta == 0 or theta == 6.28:
                        streetPoint2Flag = True

                    intersectionPoint, streetPoint1, streetPoint2 = revertPoints(intersectionPoint,
                                                                                streetPoint2,
                                                                                streetPoint1)
                    
                    if streetPoint1Flag == True:
                        # print("flag1", intersectionPoint, streetPoint1, streetPoint2)
                        verticesList.append(streetPoint1)

                    if streetPoint2Flag == True:
                        # print("flag2", intersectionPoint, streetPoint1, streetPoint2)
                        verticesList.append(streetPoint2)
        

        # Remove duplicates.
        printVerticesList = []
        for node in verticesList:
            if node not in printVerticesList:
                node = [round(node[0],5),round(node[1],5)]
                printVerticesList.append(node)



        '''
        Construction of the modified database list with the intersection
        vertices inserted into the correct position.
        '''
        for i in range(len(self.listOfStreetCoord)):
            streetCounter = 0

            for j in range(len(self.listOfStreetCoord[i]) - 1):

                # Street segment.
                a = self.listOfStreetCoord[i][j]
                b = self.listOfStreetCoord[i][j + 1]
                # print("a and b", a, b)

                # The vertices must be sorted in order of increasing distances from the 
                # preceding point on the street segment st. if two intersections occur 
                # on the same segment that the intersections are placed in 
                # varListOfStreetCoord in the correct order.
                vertexDistance = []
                for interVertex in intersectVertices:
                    vertexDistance.append(distance(a, interVertex))
                    # print("interVertex",interVertex)
                    # print(distance(a, interVertex))
                try:
                    # Pair the elements in the two lists, sort the elements, then separate the lists.
                    vertexDistance, intersectVertices = zip(*sorted(zip(vertexDistance, intersectVertices)))  
                except:
                    vertexDistance = vertexDistance
                    intersectVertices = intersectVertices

                # segmentCounter is used to track multiple intersections on the same street segment.
                # streetCounter is used to track multiple intersections on the same entire street.
                segmentCounter = 0
                for c in intersectVertices:
                    
                    if isBetweenPoints(a, c, b):
                        varListOfStreetCoord[i].insert(j + 1 + segmentCounter + streetCounter, c)
                        segmentCounter += 1

                streetCounter = streetCounter + segmentCounter


        # printGraph(printVerticesList, varListOfStreetCoord, intersectVertices)
        genOutputForPipe(printVerticesList, varListOfStreetCoord, intersectVertices)



# Simple parsing function for all operations except the remove operation.
def stringParser(line):

    isSuccess = True
    coordList = []
    nameIndices = [ind for ind, val in enumerate(line) if val == '"']
    # print(nameIndices)
    
    if len(nameIndices) == 2:
        name = line[nameIndices[0] + 1 : nameIndices[1]]
        line = line[nameIndices[1] + 1:]
        line = line.strip()
        # print(line)
    else:
        sys.stderr.write("Error: Use two double quotes to denote street name.\n")
        name = "NA"
        isSuccess = False
        return name, coordList, isSuccess

    bracketIndicesLeft = [ind for ind, val in enumerate(line) if val == '(']
    bracketIndicesRight = [ind for ind, val in enumerate(line) if val == ')']
    bracketIndices = bracketIndicesLeft + bracketIndicesRight

    if len(bracketIndices) % 2 == 0 and len(bracketIndices) != 0:
        coordString = line[ bracketIndicesLeft[0] : ]
        # print(coordString)
    elif len(bracketIndices) == 0:
        sys.stderr.write("Error: No brackets detected to denote coordinates.\n")
        isSuccess = False
        return name, coordList, isSuccess
    else:
        sys.stderr.write("Error: Missing parentheses.\n")
        isSuccess = False
        return name, coordList, isSuccess

    coords = coordString
    coordString = coords.translate( None, string.whitespace )
    # print(coordString)

    pairList = coordString.split(")(")
    # print(pairList)

    for pair in pairList:
        # print(pair)
        if pair.startswith('('):
            pair = pair[1:]
            # print(pair)
        elif pair.endswith(')'):
            pair = pair[0:len(pair) - 1]
            # print(pair)
        else:
            pair = pair
            # print(pair)

        tempList = pair.split(',')
        tempList[0] = float(tempList[0])
        tempList[1] = float(tempList[1]) 
        coordList.append(tempList)

    #print(coordList)

    return name, coordList, isSuccess


# Simple parsing function only for the remove operation.
def removeStringParser(line):

    isSuccess = True
    nameIndices = [ind for ind, val in enumerate(line) if val == '"']
    
    if len(nameIndices) == 2:
        name = line[nameIndices[0] + 1 : nameIndices[1]]
        line = line[nameIndices[1] + 1:]
        line = line.strip()
    else:
        sys.stderr.write("Error: Use two double quotes to denote street name.\n")
        isSuccess = False
        return name, isSuccess

    return name, isSuccess



# Instantiate StreetList object.
objStreetList = StreetList()


# Enter main program.
def main():

    # sys.stdout.write("V 10\n")
    # sys.stdout.write("E {<3,0>,<0,2>,<7,1>,<1,6>,<5,0>,<0,1>,<1,4>,<9,1>,<1,8>}\n")

    while True:

        try:
            # sys.stdout.write("Enter street data: \n")
            line = sys.stdin.readline()
            line = line.lower()
            line = line.strip()

        except:
            sys.stderr.write("Error: Incorrectly formatted input.")

        # Condition to check if a line was entered.
        if len(line) == 0:
            sys.stderr.write("Error: No input detected. Please enter street data or press q to exit.\n")
            continue

        # Condition to check for a valid command.
        if line[0] not in ('a', 'c', 'r', 'g', 'l', 'q'):
            sys.stderr.write("Error: Invalid operation given. Valid operations: 'a', 'c', 'r', 'g', or 'q'.\n")
            continue

        # 'a' command to add a steet.
        elif line[0] == 'a':
            # print(line)
            line = line[1:]
            line = line.strip()
            # print(line)  

            try:
                name, coordList, isSuccess = stringParser(line)    
            except:
                sys.stderr.write("Error: Input is improperly formatted.\n")
                isSuccess = False

            if isSuccess:
                objStreetList.addStreet(name, coordList)

        # 'c' command to change a street.
        elif line[0] == 'c':
            line = line[1:]
            line = line.strip()
            # print(line)  

            try:
                name, coordList, isSuccess = stringParser(line)    
            except:
                sys.stderr.write("Error: Input is improperly formatted.\n")
                isSuccess = False

            if isSuccess:
                objStreetList.changeStreet(name, coordList)

        # 'r' command to remove a street.
        elif line[0] == 'r':
            line = line[1:]
            line = line.strip()
            # print(line)  

            try:
                name, isSuccess = removeStringParser(line)    
            except:
                sys.stderr.write("Error: Input is improperly formatted.\n")
                isSuccess = False

            if isSuccess:
                objStreetList.removeStreet(name)

        # 'g' command to output graph.
        elif line[0] == 'g':
            objStreetList.generateGraph()

        # 'l' command to print database list.
        elif line[0] == 'l':
            print("\n")
            print("Street Names:\n")
            print(objStreetList.listOfStreetNames)
            print("\n")
            print("Street Coordinates Values:\n")
            print(objStreetList.listOfStreetCoord)
            continue

        # 'q' to quit.
        elif line[0] == 'q':
            break

    return 

if __name__ == '__main__':
    main()

# a "Weber Street" (2,-1) (2,2) (5,5) (5,6) (3,8)
# a "King Street S" (4,2) (4,8)
# a "Davenport Road" (1,4) (5,8)
# a "1" (3,-6) (-3,-4)"
# "a "2" (-3,2) (4,-8)"
#
# c "Weber Street" (2,1) (2,2)
#
# r "King Street S"

# Fork a Child Process.
# Open a Pipe to the Child and Read what the Child Writes to it
# def spawnModule (commandString):

#     (r,w)= os.pipe()
#     pid= os.fork()

#     if (pid < 0):
#         print "Error in Forking"
#         sys.exit (-1)

#     elif (pid == 0):

#         # Child Process
#         os.close (r)
#         writeFD= "%d"%w
#         args=[]
#         args.append (commandString)
#         args.append (writeFD)
#         os.execv (args[0],args)

#     else:

#         # Parent Process
#         os.close (w)
#         nbytes= 1024
#         string= os.read (r,nbytes)
#         print "Received This String -> ", string
#         os.close (r)

#     return pid